# Part of RedELK
#
# In this file we configure the logstash filtes for CobaltStrike teamserver logs
#
# Author: Outflank B.V. / Marc Smeets
#

filter {
  if [infralogtype] == "rtops" and [c2program] == "cobaltstrike" {

    if [c2logtype] == "events" {
      # Get the timestamp from the log line, and get the rest of the log line
      # Since CS version 3.14 the logging changed to include the UTC keyword
      if " UTC " not in [message] {  # check for legacy CS version, will be removed in the future
        grok {
          match => { "message" => "(?<c2timestamp>%{MONTHNUM}\/%{MONTHDAY} %{HOUR}\:%{MINUTE}) %{GREEDYDATA:c2message}" }
        }
        # Set the timestamp from the log to @timestamp
        date {
          match => [ "c2timestamp", "MM/dd HH:mm" ]
          target => "@timestamp"
          timezone => "Etc/UTC"
        }
      } else {  # check for newer version of CS, contains "UTC" in time logging lines
        grok {
          match => { "message" => "(?<c2timestamp>%{MONTHNUM}\/%{MONTHDAY} %{HOUR}\:%{MINUTE}\:%{SECOND}) UTC %{GREEDYDATA:c2message}" }
        }
        # Set the timestamp from the log to @timestamp
        date {
          match => [ "c2timestamp", "MM/dd HH:mm:ss" ]
          target => "@timestamp"
          timezone => "Etc/UTC"
        }
      } # end of legacy CS version check

      # matching lines like: *** initial beacon from username@ip (hostname)
      if " initial beacon from " in [c2message] {
        mutate {
          replace  => { "c2logtype" => "events_newimplant" }
        }

        grok {
          match => { "c2message" => "((/*** initial beacon from)) (?<target_user>([^@]*))\@%{IPORHOST:target_ipint} \((?<target_hostname>([^)]*))" }
        }
      }

      # matching lines like: *** user joined
      if " joined" in [c2message] or " quit" in [c2message] {
        mutate {
          replace  => { "c2logtype" => "events_joinleave" }
        }
      }
    }

    if [c2logtype] == "beacon" {
      # Get the timestamp from the log line, and get the rest of the log line
      # Since CS version 3.14 the logging changed to include the UTC keyword
      if " UTC " not in [message] {  # check for legacy CS version, will be removed in the future
        grok {
          match => { "message" => "(?<c2timestamp>%{MONTHNUM}\/%{MONTHDAY} %{TIME}) %{GREEDYDATA:c2message}" }
        }
        # Set the timestamp from the log to @timestamp
        date {
          match => [ "c2timestamp", "MM/dd HH:mm" ]
          target => "@timestamp"
          timezone => "Etc/UTC"
        }
      } else {  # check for newer version of CS, contains "UTC" in time logging lines
        grok {
          match => { "message" => "(?<c2timestamp>%{MONTHNUM}\/%{MONTHDAY} %{TIME}) UTC %{GREEDYDATA:c2message}" }
        }
        # Set the timestamp from the log to @timestamp
        date {
          match => [ "c2timestamp", "MM/dd HH:mm:ss" ]
          target => "@timestamp"
          timezone => "Etc/UTC"
        }
      } # end of legacy CS version check

      # Add path/URI value to the full beacon.log file
      ruby {
        path => "/etc/logstash/ruby-scripts/cs_makebeaconlogpath.rb"
      }

      # Set the beacon id from the file name
      # Need to match for 2 different occurence, one where the IP address is known based on the file name, and one where it states 'unknown'.
      # It is expected that the logs are in the default subdirectory of the folder cobaltstrike: /cobaltstrike/logs/
      grok {
        match => { "source" => [ "/cobaltstrike/logs/((\d{6}))/%{IPORHOST:target_ipint}/beacon_(?<implant_id>(\d{1,10}))", "/cobaltstrike/logs/((\d{6}))/unknown/beacon_(?<implant_id>(\d{1,10}))" ] }
      }

      # matching lines like: [metadata] 1.2.3.4 <- 10.10.10.10; computer: SomeComputername; user: SomeUsername; pid: 7368; os: Windows; version: 6.1; beacon arch: x86
      # todo: this could go wrong if targetip is not an ip but a smb/TCP beacon (can list the beacon session id instead of ip address..? In such case also set the implant_link value to true
      if "[metadata] " in [c2message] {
        mutate {
          replace  => { "c2logtype" => "implant_newimplant" }
        }
        # need to match 2 types of lines, one for regular HTTP(S) beacon where the ext IP field is an IP, and one for SMB/TCP beacons where the ext IP field is a field like "beacon_12345"
        grok {
          match => { "c2message" => [ "[metadata](([^\s]*)) %{IPORHOST:target_ipext} (([^\s]*)) %{IPORHOST}((\; computer:)) (?<target_hostname>([^\;]*))((\; user:)) (?<target_user>([^\;]*))((\; process:)) (?<target_process>([^\;]*))((\; pid:)) (?<target_pid>([^\;]*))((\; os:)) (?<target_os>([^\;]*))((\; version:)) (?<target_osversion>([^\;]*))((\; beacon arch:)) (?<implant_arch>([^\;]*))","[metadata](([^\s]*)) beacon_%{NUMBER:implant_linkparentid} (([^\s]*)) %{IPORHOST}((\; computer:)) (?<target_hostname>([^\;]*))((\; user:)) (?<target_user>([^\;]*))((\; process:)) (?<target_process>([^\;]*))((\; pid:)) (?<target_pid>([^\;]*))((\; os:)) (?<target_os>([^\;]*))((\; version:)) (?<target_osversion>([^\;]*))((\; beacon arch:)) (?<implant_arch>([^\;]*))" ] }
        }

        # now duplicate this specific log line, remove some irrelevant fields and make it ready to store in the ImplantsDB index (different output)
        clone {
          clones => [ "implantsdb" ]
          remove_field => [ "c2logtype","c2message","host","infralogtype" ]
        }
        # Now set beacon link information if its a linked beacon.
        if [implant_linkparentid] {
            mutate {
              add_field => { "implant_linked" => "true" }
              add_field => { "implant_linkmode" => "child" }
            }
        }
      }

      # matching lines like: [task] Tasked beacon to sleep for 3600s (20% jitter)
      if "[task] " in [c2message] {
        mutate {
          replace  => { "c2logtype" => "implant_task" }
        }
  
        grok {
          match => { "c2message" => "(([^\s]*)) %{GREEDYDATA:implant_task}" }
        }

        # Since Cobalt Strike v3.14 the task log line contains MITRE ATT&CK numbers of the task that is about to be performed. 
        # Example: [task] <T1113, T1093> Tasked beacon to take screenshot
        # Here we check if '<T' and '>' are in c2message. If so, we parse the field. If not, we assume its an old CS version and skip the creation of the ATT&CKTechnique field.
        # We also check if there are multiple values, and if so split them up
        if "<T" in [implant_task] and ">" in [implant_task] {
          grok {
            match => { "implant_task" => "<(?<attack_technique>([^\>]*))> " }
          }
          mutate {
            split => { "attack_technique" => ", " }
          }
        }
      }

      # matching lines like: [checkin] host called home, sent: 16 bytes
      if "[checkin] " in [c2message] {
        mutate {
          replace  => { "c2logtype" => "implant_checkin" }
        }

        grok {
          match => { "c2message" => "(([^\s]*)) %{GREEDYDATA:implant_checkin}" }
        }
      }

      # matching lines like: [input] <Operator> note s3600 20
      if "[input] " in [c2message] {
        mutate {
          replace  => { "c2logtype" => "implant_input" }
        }

        grok {
          match => { "c2message" => "(([^\s]*)) %{GREEDYDATA:implant_input}" }
        }
      }

      # matching lines like: [indicator] SomethingSomething
      if "[indicator]" in [c2message] {
        mutate {
          replace => { "c2logtype" => "ioc" }
        }

        # need to match 2 types of lines: one for file and one for service indicators
        grok {
          match => { "c2message" => [ "((^\[indicator\])) (?<ioc_type>([^\:]*))((:)) %{NOTSPACE:ioc_hash} %{POSINT:ioc_bytesize} ((bytes)) %{GREEDYDATA:ioc_name}","((^\[indicator\])) (?<ioc_type>([^\:]*))((:)) %{WINPATH:ioc_path} %{NOTSPACE:ioc_name}" ] }
        }
      }

      # matching lines like: [output]\nSomethingSomething
      if "[output]" in [c2message] {
        mutate {
          replace  => { "c2logtype" => "implant_output" }
        }

        grok {
          match => { "c2message" => "]\n%{GREEDYDATA:implant_output}" }
        }

        # check for messages like: established link to parent beacon: 1.2.3.4
        # todo: add check for recursive smb/TCP beacons (child becomes another beacon's parent). For now this parent-child indication is wrong when a child becomes a parent of another linked beacon
        if "established link to parent beacon" in [implant_output] {
          grok {
            match => { "implant_output" => "((established link to parent beacon: ))%{IPORHOST:target_linkparentnode}" }
            add_field => { "implant_linked" => "true" }
            add_field => { "implant_linkmode" => "child" }
          }
        }
        if "established link to child beacon" in [implant_output] {
          grok {
            match => { "implant_output" => "((established link to child beacon: ))%{IPORHOST:target_linkchildnode}" }
            add_field => { "implant_linked" => "true" }
            add_field => { "implant_linkmode" => "parent" }
          }
        }

        # check for received screenshots and add a path value to the screenshot
        if "received screenshot (" in [implant_output] {
          ruby {
            path => "/etc/logstash/ruby-scripts/cs_makescreenshotpath.rb"
          }
        }
      }

      # matching lines like: [error]\nSomethingSomething
      if "[error]" in [c2message] {
        mutate {
          replace  => { "c2logtype" => "implant_error" }
        }

        grok {
          match => { "c2message" => "]%{GREEDYDATA:implant_output}" }
        }
      }
    }

    if [c2logtype] == "keystrokes" {
      # Get the timestamp from the log line, and get the rest of the log line
      # Since CS version 3.14 the logging changed to include the UTC keyword
      if " UTC " not in [message] {  # check for legacy CS version, will be removed in the future
        grok {
          match => { "message" => "(?<c2timestamp>%{MONTHNUM}\/%{MONTHDAY} %{TIME}) %{GREEDYDATA:c2message}" }
        }
        # Set the timestamp from the log to @timestamp
        date {
          match => [ "c2timestamp", "MM/dd HH:mm:ss" ]
          target => "@timestamp"
          timezone => "Etc/UTC"
        }
      } else {  # check for newer version of CS, contains "UTC" in time logging lines
        grok {
          match => { "message" => "(?<c2timestamp>%{MONTHNUM}\/%{MONTHDAY} %{TIME}) UTC %{GREEDYDATA:c2message}" }
        }
        # Set the timestamp from the log to @timestamp
        date {
          match => [ "c2timestamp", "MM/dd HH:mm:ss" ]
          target => "@timestamp"
          timezone => "Etc/UTC"
        }
      }

      # Set the beacon id from the file name
      # Need to match for 2 different occurence, one where the IP address is known based on the file name, and one where it states 'unknown'.
      # It is expected that the logs are in the default subdirectory of the folder cobaltstrike: /cobaltstrike/logs/
      grok {
        match => { "source" => [ "/cobaltstrike/logs/((\d{6}))/%{IPORHOST:target_ipint}/keystrokes/keystrokes_(?<implant_id>(\d{1,10}))", "/cobaltstrike/logs/((\d{6}))/unknown/keystrokes/keystrokes_(?<implant_id>(\d{0,10}))" ] }
      }

      # add url to full keystrokes file
      ruby {
        path => "/etc/logstash/ruby-scripts/cs_makekeystrokespath.rb"
      }
    }

    if [c2logtype] == "downloads" {
      if " UTC " not in [message] {  # check for legacy CS version, will be removed in the future
        # Matching lines like: #1546505606424    10.202.1.11    12654    7    /root/cobaltstrike/downloads/9ce6fbfb1    testdoc.txt    C:\Users\Administrator\Desktop\
        grok {
          # This type of log does not have a regular timestamp, but it does have a large int at the beginning. Lets throw that away as we have no use for it now.
          match => { "message" => "%{WORD}(\t)%{GREEDYDATA:c2message}" }
        }
        grok {
          match => { "c2message" => "%{IP:target_ipint}(\t)(?<implant_id>(\d{0,10}))(\t)%{INT}(\t)%{NOTSPACE:pathlocal}(\t)(?<filename>([^\t]*))(\t)%{GREEDYDATA:pathremote}" }
        }
      } else {  # check for newer version of CS, contains "UTC" in time logging lines
        # matching lines like: 05/25 13:29:44 UTC      192.168.217.131 93439   70      /root/cobaltstrike/downloads/2914cdfa8  helloworld.ps1  C:\users\marcs\Desktop\
        grok {
          match => { "message" => "(?<c2timestamp>%{MONTHNUM}\/%{MONTHDAY} %{HOUR}\:%{MINUTE}\:%{SECOND}) UTC(\t)%{GREEDYDATA:c2message}" }
        }
        grok {
          match => { "c2message" => "%{IP:target_ipint}(\t)(?<implant_id>(\d{0,10}))(\t)%{INT}(\t)%{NOTSPACE:pathlocal}(\t)(?<filename>([^\t]*))(\t)%{GREEDYDATA:pathremote}" }
        }        
        # Set the timestamp from the log to @timestamp
        date {
          match => [ "c2timestamp", "MM/dd HH:mm:ss" ]
          target => "@timestamp"
          timezone => "Etc/UTC"
        }
      } # end of legacy CS version check
        
      # add url to full keystrokes file
      ruby {
        path => "/etc/logstash/ruby-scripts/cs_makedownloadspath.rb"
      }
    }

    if [c2logtype] == "credentials" {
      # Drop the first line with headers
      if "#User" in [message] {
        drop { }
      }

      #Parse the lines with credentials
      grok {
        match => { "message" => "(?<realm>([^\\]*))\\(?<username>([^\t]*))\t(?<credential>([^\t]*))\t(?<extracted_from>([^\t]*))\t(?<extracted_via>([^\t]*))"  }
      }
    }
  }
}

