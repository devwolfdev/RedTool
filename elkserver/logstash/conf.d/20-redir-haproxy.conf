# Part of RedELK
#
# In this file we configure the logstash filtes for HAproxy logs
#
# Author: Outflank B.V. / Marc Smeets
#

filter {
  if [infralogtype] == "redirtraffic" and [redirprogram] == "haproxy" {

    # Filebeat introduces the source field for the name of the log file path. But this collides with source object from the Elastic Common Schema.
    # We have no need for the filebeat's field as its also stored in log.file.path. So we drop it.
    mutate {
      remove_field => [ "source" ]
    }

    # drop haproxy log lines about the service starting and stopping
    if "haproxy-systemd-wrapper" in [message] {
      drop { }
    }
    if "Proxy " in [message] and " started." in [message] {
      drop { }
    }
    # drop haproxy log lines when there is a config error
    if " [ALERT] " in [message] {
       drop { }
    }
    if " [ SSL] " in [message] {
       drop { }
    }
    if " [ ALL] " in [message] {
       drop { }
    }
    if " [UNIX] " in [message] {
       drop { }
    }
    if " [STAT] " in [message] {
       drop { }
    }
    if " [ TCP] " in [message] {
       drop { }
    }

    # Sometimes HAproxy will report an SSL handshake failure, using a different log line. We check for that as well
    if "SSL handshake failure" in [message] {
      grok {
        match => { "message"=> [ "%{SYSLOGTIMESTAMP} %{IPORHOST:redir.host} %{SYSLOGPROG}: %{IPORHOST:source.ip}:%{POSINT:source.port} \[(?<redir.traffic.timestamp>%{MONTHDAY}\/%{MONTH}\/%{YEAR}:%{TIME})] (?<redir.frontend>([^/]*))%{GREEDYDATA:redir.traffic.request}" ] }
      }
      mutate {
        add_field => { "redir.destination" => "ssl-error" }
      }
      # Set the timestamp from the log to @timestamp, example: 16/Sep/2018:07:08:21.783
      date {
        match => [ "redir.traffic.timestamp", "dd/MMM/yyyy:HH:mm:ss.SSS" ]
        target => "@timestamp"
        timezone => "Etc/UTC"
      }
    }

    # now matching the real haproxy lines. We have several log line formats we need to match:
    # - Lines without X-Forwarded-For identified with "xforwardedfor:-"
    # - Lines with X-Forwarded-For set, identified with "xforwardedfor:$SOMEIP"
    # - any other weird sitution, i.e. cutoff lines when the log lne is larger than the redir's logbuffer size
    # Sometimes HAProxy reports lines with 'message repeated X times' in it. This is inserted into the line after the SYSLOGPROG, before "frontend. So we grok match (%{GREEDYDATA})? in each line
    #
    # We'll walk through them one by one
    #

    if "xforwardedfor:-" in [message] {
      # Lines without X-Forwarded-For identified with "xforwardedfor:-"
        grok {
          match => { "message" => [ "%{SYSLOGTIMESTAMP} %{IPORHOST:redir.host} %{SYSLOGPROG}:(%{GREEDYDATA})? frontend:(?<redir.frontend>([^/]*))/(([^/]*))/%{IPORHOST:redir.frontendip}:%{POSINT:redir.frontendport} backend:%{NOTSPACE:redir.destination} client:%{IPORHOST:source.ip}:%{POSINT:source.port} GMT:%{HTTPDATE:redir.traffic.timestamp} useragent:(?<redir.traffic.useragent>(.*)) xforwardedfor:- headers:\{\|(?<redir.traffic.headers>([^\}]*))} request:%{GREEDYDATA:redir.traffic.request}" ] }
        }
        mutate {
          split => { "redir.traffic.headers" => "|" }
        }
    } else if "request:" in [message] {
    # Lines with X-Forwarded-For set. We already filtered out the 'xfordwardedfor:-', so anything left with a large enough log line should be good 
      grok {
        match => { "message" => [ "%{SYSLOGTIMESTAMP} %{IPORHOST:redir.host} %{SYSLOGPROG}:(%{GREEDYDATA})? frontend:(?<redir.frontend>([^/]*))/(([^/]*))/%{IPORHOST:redir.frontendip}:%{POSINT:redir.frontendport} backend:%{NOTSPACE:redir.destination} client:%{IPORHOST:source.ipcdn}:%{POSINT:source.portcdn} GMT:%{HTTPDATE:redir.traffic.timestamp} useragent:(?<redir.traffic.useragent>(.*)) xforwardedfor:%{IPORHOST:source.ip} headers:\{\|(?<redir.traffic.headers>([^\}]*))} request:%{GREEDYDATA:redir.traffic.request}" ] }
      }
    } else {
    # catchall situation, i.e. cutoff lines when the log lne is larger than the redir's logbuffer size
      grok {
        match => { "message" => [ "%{SYSLOGTIMESTAMP} %{IPORHOST:redir.host} %{SYSLOGPROG}:(%{GREEDYDATA})? frontend:(?<redir.frontend>([^/]*))/(([^/]*))/%{IPORHOST:redir.frontendip}:%{POSINT:redir.frontendport} backend:%{NOTSPACE:redir.destination} client:%{IPORHOST:source.ip}:%{POSINT:source.port} GMT:%{HTTPDATE:redir.traffic.timestamp} %{GREEDYDATA:redir.traffic.catchall}" ] }
        add_tag => [ "redirlongmessagecatchall" ]
      }
    }
    
    # Set the timestamp from the log to @timestamp, example: 15/Apr/2018:19:22:31 +0000
    date {
      match => [ "redir.traffic.timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
      target => "@timestamp"
      timezone => "Etc/UTC"
    }

    # When IPv6 is enabled on your HAProxy host, IPV4 addresses are reported like ::ffff:ipv4address. Here we cut off the ::ffff: part
    if "ffff" in [source.ip] {
      mutate {
        gsub => [
          "source.ip", "\:\:ffff\:", ""
        ]
      }
    }
    if "ffff" in [destination.ip] {
      mutate {
        gsub => [
          "destination.ip", "\:\:ffff\:", ""
        ]
      }
    }
    if "ffff" in [source.ipcdn] {
      mutate {
        gsub => [
          "source.ipcdn", "\:\:ffff\:", ""
        ]
      }
    }

    # Add data to the source.ip
    if [source.ip] {
      # duplicate field so we can replace it with reverse DNS lookup
      mutate {
        add_field => { "source.dns" => "%{source.ip}" }
      }
      # do reverse DNS lookup
      dns {
        reverse => ["source.dns"]
        action => "replace"
        timeout => "2.0"
      }
      # add geo ip info from City DB
      geoip {
        source => "source.ip"
        database => "/usr/share/logstash/GeoLite2-dbs/GeoLite2-City.mmdb"
      }
      # add geo ip info from ASN DB
      geoip { 
        source => "source.ip"
        default_database_type => "ASN"
        database => "/usr/share/logstash/GeoLite2-dbs/GeoLite2-ASN.mmdb"
      }
    }
    # Add data to the source.ipcdn
    if [source.ipcdn] {
      # duplicate field so we can replace it with reverse DNS lookup
      mutate {
        add_field => { "source.dnscdn" => "%{source.ipcdn}" }
      }
      # do reverse DNS lookup
      dns {
        reverse => ["source.dnscdn"]
        action => "replace"
        timeout => "2.0"
      }
      # add geo ip info from City DB
      geoip {
        source => "source.ipcdn"
        database => "/usr/share/logstash/GeoLite2-dbs/GeoLite2-City.mmdb"
      }
      # add geo ip info from ASN DB
      geoip { 
        source => "source.ipcdn"
        default_database_type => "ASN"
        database => "/usr/share/logstash/GeoLite2-dbs/GeoLite2-ASN.mmdb"
      }
    }
  }
}
