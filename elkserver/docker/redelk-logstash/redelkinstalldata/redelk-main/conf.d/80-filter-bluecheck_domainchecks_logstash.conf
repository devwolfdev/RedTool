# Part of RedELK
#
# In this file we parse the output of BLUECHECK tools
#
# Author: Outflank B.V. / Marc Smeets
#

filter {
  ## First we check if we have new fields that are bluecheck related and have the 'type' not set to bluecheck
  # 
  if "BLUECHECK" in [implant][output] {
    clone {
      clones => [ "bluecheck" ]
      remove_field => [ "[c2][log][type]","[infra][log][type]" ]
    }

    # check if bluechecktype should be set to sslcert
    if "SSL Certicate" in [implant][output] {
    mutate {
      add_field => { "bluechecktype" => "sslcert"}
    }

    # check if bluechecktype should be set to pwchange
    if "BLUECHECK Password" in [implant][output] {
    mutate {
      add_field => { "bluechecktype" => "pwchange"}
    }

    # check if bluechecktype should be set to sectools
    if "BLUECHECK Security Tools Check" in [implant][output] {
    mutate {
      add_field => { "bluechecktype" => "sectools"}
    }


  }
  
  ## Now parse fields with type == bluecheck
  if [type] == "bluecheck" {
    
    # parse output of sslcert checks
    if [bluechecktype] == "sslcert" {
      grok {
        match => { "[implant][output]" => "((.|\r|\n)*) BLUECHECK SSL Certificate\: (?<[bluecheck][message]>(.|\r|\n)*)\[\+\] Check Finished" }
      }
      grok {
        match => { "[bluecheck][message]" => "%{URI:[bluecheck][uri]}%{GREEDYDATA} Subject Information:\\n%{GREEDYDATA:[bluecheck][certsubject]}\\n\[\+\] Issuer Information\:\\n%{GREEDYDATA:[bluecheck][certissuer]}\\n" }
      }
    }

    # parse output of PasswordChangeCheck
    if [bluechecktype] == "pwchange" {
      grok {
        match => { "[implant][output]" => "((.|\r|\n)*) BLUECHECK Password\: (?<[bluecheck][message]>(.|\r|\n)*)\n" }
      }
      grok {
        match => { "[bluecheck][message]" => "(?<[bluecheck][accountname]>(.|\r|\n)*) password last changed at\: (?<[bluecheck][pwchangedate]>%{MONTHNUM}\/%{MONTHDAY}\/%{YEAR} %{HOUR}\:%{MINUTE}\:%{SECOND}), account %{WORD:[bluecheck][accountstate]}." }
      }
      date {
        match => [ "[bluecheck][pwchangedate]", "MM/dd/YYYY HH:mm:ss" ]
        target => "@timestamp"
        timezone => "Etc/UTC"
      }
    }

    # parse output of sectools checks
    if [bluechecktype] == "sectools" {
      grok {
        match => { "[implant][output]" => "((.|\r|\n)*) BLUECHECK Security Tools check\:\n(?<[bluecheck][message]>(.|\r|\n)*)\[\+\] Check Finished" }
      }
      grok {
        match => { "[bluecheck][message]" => "\[\+\] Security products found: %{INT:[bluecheck][sectoolsamount]}\\n%{GREEDYDATA:[bluecheck][sectools]}\\n\\n" }
      }
      # TODO cleanup the list of sectools
      #mutate {
      #    gsub => ["[bluecheck][sectools]]", "\n    Product:\t", " -"]
      #  }

    }





    # roguedomaincheck is different in the sense that data is read from config file elkserver/mounts/redelk-config/etc/redelk/redteamdomains.conf
    # filebeat already sets the type field; there is no event from rtops duplicated.
    # parse output of roguedomaincheck
    if [bluechecktype] == "roguedomaincheck" {
      grok {
        match => { "message" => "(?<bluechecktimestamp>%{YEAR}\/%{MONTHNUM}\/%{MONTHDAY}, %{HOUR}\:%{MINUTE}\:%{SECOND}) Domain\: %{IPORHOST:domain} Source\: %{GREEDYDATA:classifier} Results\: %{GREEDYDATA:results}" }
      }
      date {
        match => [ "bluechecktimestamp", "YYYY/MM/dd, HH:mm:ss" ]
        target => "@timestamp"
        timezone => "Etc/UTC"
      }
      mutate { 
        remove_field => [ "host" ]
      }
    }

    if [pstools][psx][edr_name] {
      mutate {
        add_field => { "bluechecktype" => "psx"}
      }
    }
  }
}